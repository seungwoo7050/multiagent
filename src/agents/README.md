# Multi-Agent System Documentation

## Architecture Overview

The Multi-Agent System implements a high-performance framework for AI agent orchestration with a focus on planning and execution tasks. The architecture follows these key principles:

- **Asynchronous Processing**: All core operations are non-blocking with async/await patterns
- **Modularity**: Clear separation of agent capabilities and responsibilities
- **Context Protocol**: Model Context Protocol (MCP) standardizes data exchange
- **Singleton Patterns**: Shared resources like factories use thread-safe singleton patterns
- **Error Resilience**: Comprehensive error handling with typed exceptions

The system consists of these primary modules:

| Module | Purpose | Key Components |
|--------|---------|----------------|
| `agents` | Agent definition and orchestration | MCPPlannerAgent, MCPExecutorAgent, AgentFactory |
| `core` | Core abstractions and interfaces | BaseAgent, AgentContext, Task |
| `mcp` | Model Context Protocol implementation | Context schemas, adapters, serialization |
| `config` | System configuration | Settings, logging, metrics |
| `tools` | Tool implementations | ToolRegistry, ToolRunner |
| `llm` | LLM provider integration | LLMAdapter |

### Design Patterns

- **Factory Pattern**: `AgentFactory` centralizes agent creation with caching
- **Adapter Pattern**: `LLMAdapter` normalizes different LLM providers
- **Singleton Pattern**: Used for factories and registries
- **Command Pattern**: Tools follow a command pattern with standardized execution
- **Observer Pattern**: Metrics collection observes system operations

### Key Abstractions

- **BaseAgent**: Abstract foundation for all agent implementations
- **AgentCapability**: Enumeration of agent capabilities (planning, execution, etc.)
- **ContextProtocol**: Interface for standardized context exchange
- **TaskContext**: Representation of tasks and their metadata

## Component Details

### AgentFactory

#### Purpose
The AgentFactory manages agent creation, caching, and lifecycle control, implementing a thread-safe singleton pattern for efficient resource usage.

#### Core Classes
- `AgentFactory`: Central factory for agent creation
- `get_agent_factory()`: Async function returning the singleton instance

#### Key Features
- Agent instance caching with idle timeout
- Initialization state tracking
- Dynamic agent type resolution
- Proper resource cleanup on shutdown

#### Usage Example

```python
# Get factory singleton
factory = await get_agent_factory()

# Register configuration
config = AgentConfig(
    name="my_planner",
    agent_type="mcp_planner",
    capabilities={"planning", "reasoning"},
    model="gpt-4o"
)
factory.register_agent_config(config)

# Get agent (creates or retrieves from cache)
agent = await factory.get_agent("my_planner")

# Use the agent
result = await agent.process(context)

# Clean up resources when done
await factory.shutdown()
```

#### Implementation Details
- Agent instances are cached as tuples: `(agent, last_used_timestamp, is_initialized)`
- Initialization state is tracked to handle cached but uninitialized agents
- Thread safety ensured via asyncio locks
- Idle agents are cleaned up periodically

### MCPPlannerAgent

#### Purpose
The MCPPlannerAgent generates structured plans using LLMs to solve complex tasks, following a standardized JSON format.

#### Core Methods
- `initialize()`: Prepares the agent for operation
- `process(context)`: Core method that generates task plans
- `handle_error(error, context)`: Error handling implementation

#### Key Features
- Generates structured step-by-step plans
- Leverages LLM for reasoning and planning
- Standardized JSON-based plan format
- Robust error handling
- Context optimization

#### Usage Example

```python
# Create planner configuration
planner_config = AgentConfig(
    name="task_planner",
    agent_type="mcp_planner",
    model="gpt-4o",
    capabilities={"planning", "reasoning"},
    allowed_tools=["web_search", "calculator"]
)

# Create the planner agent
planner = MCPPlannerAgent(config=planner_config)
await planner.initialize()

# Create a task context
task_context = AgentContext(
    task=task,
    trace_id="trace-123",
    memory={"conversation_history": "..."}
)

# Generate a plan
result = await planner.process(task_context)

# Extract the plan
plan = result.output["plan"]
```

#### Implementation Details
- Uses LLMAdapter for model interactions
- Implements structured JSON parsing with fallbacks
- Validates plan structure and steps
- Optimizes context objects via AgentContextManager

### MCPExecutorAgent

#### Purpose
The MCPExecutorAgent executes plans generated by the planner using a ReAct (Reasoning+Acting) approach, interacting with tools and making decisions based on observations.

#### Core Methods
- `process(context)`: Executes plans through ReAct iterations
- `_generate_thought(goal, plan, scratchpad, executed_steps)`: Generates reasoning
- `_generate_action(goal, plan, scratchpad, executed_steps)`: Decides next action
- `_parse_action(action_str)`: Parses action strings into operations

#### Key Features
- ReAct execution loop with action-observation pairs
- Tool integration for external capabilities
- Structured thinking and reasoning
- JSON-based action parsing
- Detailed execution records

#### Usage Example

```python
# Create executor configuration
executor_config = AgentConfig(
    name="task_executor",
    agent_type="mcp_executor",
    model="gpt-3.5-turbo",
    capabilities={"execution", "tool_use"},
    allowed_tools=["web_search", "calculator"],
    parameters={"max_react_iterations": 5}
)

# Create the executor agent with tool registry
executor = MCPExecutorAgent(config=executor_config, tool_registry=tool_registry)
await executor.initialize()

# Create a context with a plan
executor_context = AgentContext(
    task=task_with_plan,  # Plan from planner in task.input["plan"]
    trace_id="trace-123",
    memory={"conversation_history": "..."}
)

# Execute the plan
result = await executor.process(executor_context)

# Extract the final answer
final_answer = result.output["final_answer"]
execution_record = result.output["scratchpad"]
```

#### Implementation Details
- Implements ReAct methodology with max iterations
- Uses LLM for thought generation and action decisions
- Integrates with ToolRegistry for tool execution
- Provides comprehensive execution records in scratchpad

### AgentContextManager

#### Purpose
The AgentContextManager provides efficient storage, retrieval, and optimization of context objects following the Model Context Protocol.

#### Core Methods
- `update_context(context)`: Stores or updates a context object
- `get_context(context_id, context_type)`: Retrieves contexts by ID or type
- `optimize_context(context_id, context_type)`: Optimizes contexts for efficiency
- `clear_contexts()`: Removes all stored contexts

#### Key Features
- Type-safe context storage
- Latest context tracking by type
- Context optimization for efficiency
- Comprehensive metrics tracking
- Thread-safe operations

#### Usage Example

```python
# Create a context manager for an agent
context_manager = AgentContextManager(agent_id="my_agent")

# Create and store a context
task_context = TaskContext(
    task_id="task-123",
    task_type="planning",
    input_data={"goal": "Research Python error handling"}
)
context_manager.update_context(task_context)

# Retrieve a context by ID
context = context_manager.get_context(context_id=task_context.context_id)

# Retrieve latest context by type
latest_context = context_manager.get_context(context_type=TaskContext)

# Optimize a context
optimized = context_manager.optimize_context(context_id=task_context.context_id)

# Clear all contexts when done
context_manager.clear_contexts()
```

#### Implementation Details
- Uses dictionaries for fast context lookup
- Tracks latest context IDs by type
- Integrates with optimization algorithms
- Provides detailed logging and metrics

## Usage Examples

### Complete End-to-End Agent Workflow

```python
async def process_task(task: BaseTask) -> Dict[str, Any]:
    # Get factory
    factory = await get_agent_factory()
    
    # Create agent context
    context = AgentContext(
        task=task,
        trace_id=f"trace-{uuid.uuid4()}",
        memory={"conversation_history": "..."}
    )
    
    # Get planner and generate plan
    planner = await factory.get_agent("task_planner")
    plan_result = await planner.process(context)
    
    if not plan_result.success:
        return {"status": "error", "message": "Planning failed", "details": plan_result.error}
    
    # Create executor context with the plan
    task_with_plan = task.copy()
    task_with_plan.input["plan"] = plan_result.output["plan"]
    
    executor_context = AgentContext(
        task=task_with_plan,
        trace_id=context.trace_id,
        memory=context.memory
    )
    
    # Get executor and execute plan
    executor = await factory.get_agent("task_executor")
    execution_result = await executor.process(executor_context)
    
    if not execution_result.success:
        return {"status": "error", "message": "Execution failed", "details": execution_result.error}
    
    return {
        "status": "success",
        "answer": execution_result.output["final_answer"],
        "execution_record": execution_result.output["scratchpad"],
        "plan": plan_result.output["plan"]
    }
```

### Error Handling Pattern

```python
async def safe_agent_execution(agent: BaseAgent, context: AgentContext) -> AgentResult:
    try:
        # Attempt normal execution
        return await agent.process(context)
    except AgentExecutionError as e:
        # Handle specific agent errors
        logger.error(f"Agent execution failed: {e}")
        return await agent.handle_error(e, context)
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error: {e}")
        error = AgentExecutionError(
            message=f"Unexpected error: {str(e)}",
            agent_type=agent.agent_type
        )
        return await agent.handle_error(error, context)
```

## Best Practices

### Agent Configuration

- **Clearly define capabilities**: Only include capabilities the agent actually implements
- **Use lowercase string capabilities**: Pass capabilities as lowercase strings, not enum values
- **Provide model defaults**: Always set a default model in configurations
- **Validate tool names**: Ensure allowed tools are actually available in your registry

### Agent Lifecycle Management

- **Always initialize agents**: Call and await `initialize()` before first use
- **Use the factory pattern**: Get agents via `get_agent_factory()` instead of direct instantiation
- **Leverage caching**: Use `use_cache=True` for better performance with repeated agent usage
- **Clean up resources**: Call `factory.shutdown()` when done

### Error Handling

- **Use specific exception types**: Prefer specialized exceptions over generic ones
- **Implement handle_error**: Always provide comprehensive error handling in agents
- **Include context in errors**: Add relevant context info to error details
- **Graceful degradation**: Implement fallbacks for non-critical failures

### LLM Interaction

- **Validate outputs**: Always validate LLM outputs, especially structured data like JSON
- **Implement retries**: Use retry mechanisms for transient LLM failures
- **Monitor token usage**: Track and optimize token consumption
- **Use result caching**: Cache common LLM responses when appropriate

## Testing Approach

### Test Structure

The test suite follows a modular structure mirroring the component architecture:

- **Unit Tests**: For individual components
- **Integration Tests**: For component interaction
- **End-to-End Tests**: For complete workflows

### Key Test Fixtures

- `task_input`: Sample task input data
- `sample_task`: Mocked BaseTask instance
- `agent_context`: Agent execution context
- `planner_config`: Configuration for planner agent
- `executor_config`: Configuration for executor agent
- `mock_plan_data`: Sample planning output
- `mock_agent_factory`: Factory instance for testing

### Mock Strategy

The test suite uses strategic mocking to isolate components:

- **LLM Calls**: Mocked to provide controlled responses
- **Tool Registry**: Mocked to simulate tool availability and execution
- **Agent Initialization**: Mocked to focus on specific behaviors
- **Tasks**: Mocked to provide consistent test data

### Running Tests

To run the test suite:

```bash
# Run all tests
python -m pytest tests/agents/test_agents.py

# Run specific test class
python -m pytest tests/agents/test_agents.py::TestMCPPlannerAgent

# Run with detailed output
python -m pytest tests/agents/test_agents.py -v

# Run with specific marker
python -m pytest tests/agents/test_agents.py -m asyncio
```

### Test Examples

#### Testing Configuration Validation

```python
def test_agent_config_validate_capabilities(self):
    """Test that capabilities validation works correctly."""
    # Test with valid string input
    config = AgentConfig(
        name="test-agent",
        agent_type="test",
        capabilities="planning,reasoning"  # Comma-separated string
    )
    assert len(config.capabilities) == 2
    assert any(cap.value == "planning" for cap in config.capabilities)
    assert any(cap.value == "reasoning" for cap in config.capabilities)
```

#### Testing Agent Process Method

```python
async def test_planner_process(self, planner_config, agent_context, mock_plan_data):
    """Test planner's process method with mocked LLM."""
    planner = MCPPlannerAgent(config=planner_config)
    
    # Mock the LLM adapter
    with patch.object(planner, 'llm_adapter') as mock_adapter:
        mock_output = LLMOutputContext(
            success=True,
            result_text=json.dumps(mock_plan_data),
            model_used=planner_config.model
        )
        mock_adapter.process_with_mcp = AsyncMock(return_value=mock_output)
        
        # Execute the process method
        result = await planner.process(agent_context)
        
        assert result.success is True
        assert "plan" in result.output
        assert len(result.output["plan"]) > 0
```

## Implementation Notes

### Thread Safety

- **Singleton Access**: Factory and registry access is protected by asyncio locks
- **Context Management**: Context managers handle their own synchronization
- **Agent State**: Agent state transitions are made thread-safe through careful design

### Asynchronous Programming Patterns

- **Consistent Async/Await**: All potentially blocking operations use async/await
- **Task Composition**: Complex workflows compose multiple async tasks
- **Proper Exception Handling**: AsyncExceptionGroup handling where needed
- **Cancellation Handling**: Graceful handling of task cancellation

### Critical Code Sections

- **Agent Factory**: Thread-safe singleton access pattern
- **LLM Interaction**: Robust error handling for external API calls
- **Tool Execution**: Timeout and safety mechanisms

## Key Improvements

### Agent Factory Enhancements

- **Initialization Tracking**: Added explicit tracking of agent initialization state
- **Error Propagation**: Improved error details for better debugging
- **Resource Cleanup**: Enhanced shutdown procedure for more reliable cleanup

### Agent Implementation

- **Planner Robustness**: Improved JSON parsing with multiple fallback strategies
- **Executor ReAct Loop**: Enhanced ReAct implementation with better state tracking
- **Error Handling**: More comprehensive error handling throughout the execution flow

### Testing Improvements

- **Mock Strategy**: Enhanced mock objects with better method simulation
- **TestAgentFactory**: Fixed caching test to properly inspect cache state
- **Property Mocking**: Added PropertyMock for more accurate state testing
- **Error Testing**: Comprehensive error scenario coverage

## Integration Guidelines

### System Initialization

1. Initialize configuration first
   ```python
   from src.config.settings import get_settings
   settings = get_settings()
   ```

2. Set up logging
   ```python
   from src.config.logger import setup_logging
   setup_logging()
   ```

3. Initialize metrics
   ```python
   from src.config.metrics import start_metrics_server
   start_metrics_server()
   ```

4. Get the agent factory
   ```python
   from src.agents.factory import get_agent_factory
   factory = await get_agent_factory()
   ```

5. Register agent configurations
   ```python
   for config in agent_configs:
       factory.register_agent_config(config)
   ```

### Shutdown Procedure

1. Shut down the agent factory
   ```python
   await factory.shutdown()
   ```

2. Close any open connections
   ```python
   await connections.close_all()
   ```

3. Flush metrics
   ```python
   metrics.flush()
   ```

## API Reference

### AgentFactory

```python
async def get_agent_factory() -> AgentFactory:
    """Get the singleton AgentFactory instance."""
    
class AgentFactory:
    def register_agent_class(self, agent_type: str, agent_class: Type[BaseAgent]) -> None:
        """Register a new agent class type with the factory."""
        
    def register_agent_config(self, config: AgentConfig) -> None:
        """Register a configuration for an agent."""
        
    def get_registered_agent_types(self) -> List[str]:
        """Get list of all registered agent type names."""
        
    def has_agent_type(self, agent_type: str) -> bool:
        """Check if a particular agent type is registered."""
        
    async def get_agent(self, agent_name: str, config: Optional[AgentConfig]=None,
                        use_cache: bool=True, cache_key: Optional[str]=None) -> BaseAgent:
        """Get an agent instance by name or configuration."""
        
    async def cleanup_cache(self, max_idle_time_ms: int=600000) -> int:
        """Clean up cached agent instances that haven't been used for some time."""
        
    async def shutdown(self) -> None:
        """Terminate all cached agent instances and clear the cache."""
```

### MCPPlannerAgent

```python
class MCPPlannerAgent(BaseAgent):
    def __init__(self, config: AgentConfig, memory_manager: Optional[Any]=None):
        """Initialize planner agent."""
        
    async def initialize(self) -> bool:
        """Initialize the agent. Must be called before first use."""
        
    async def process(self, context: CoreAgentContext) -> AgentResult:
        """Generate a plan based on the task in the context."""
        
    async def handle_error(self, error: Exception, context: CoreAgentContext) -> AgentResult:
        """Handle errors during planning."""
```

### MCPExecutorAgent

```python
class MCPExecutorAgent(BaseAgent):
    def __init__(self, config: AgentConfig, tool_registry: Optional[ToolRegistry]=None):
        """Initialize executor agent."""
        
    async def initialize(self) -> bool:
        """Initialize the agent. Must be called before first use."""
        
    async def process(self, context: CoreAgentContext) -> AgentResult:
        """Execute a plan provided in the context."""
        
    async def handle_error(self, error: Exception, context: CoreAgentContext) -> AgentResult:
        """Handle errors during execution."""
```

### AgentContextManager

```python
class AgentContextManager:
    def __init__(self, agent_id: str):
        """Initialize a context manager for an agent."""
        
    def update_context(self, context: ContextProtocol) -> None:
        """Store or update a context object."""
        
    def get_context(self, context_id: Optional[str]=None, 
                   context_type: Optional[Type[ContextProtocol]]=None) -> Optional[ContextProtocol]:
        """Retrieve contexts by ID or type."""
        
    def get_all_contexts(self) -> Dict[str, ContextProtocol]:
        """Get all stored context objects."""
        
    def optimize_context(self, context_id: Optional[str]=None,
                         context_type: Optional[Type[ContextProtocol]]=None) -> Optional[ContextProtocol]:
        """Optimize contexts for efficiency."""
        
    def clear_contexts(self) -> None:
        """Remove all stored contexts."""
```